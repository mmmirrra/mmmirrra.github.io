---
layout: post
title:  "Introduction to Algorithm: Introduction"
date:   2024-02-27 09:00:00 +0900
categories: [Algorithm]
---

### 기본 개념   
- 컴퓨터의 한계 : 알고리즘의 존재 여부에 따라 알고리즘이 존재하지 않으면 컴퓨터로 구현할 수 없음   
- 컴퓨터과학 : 컴퓨터를 활용해서 주어진 문제를 해결하기 위함 학문. 문제 해결을 위한 문제 풀이 절차/방법이 필요   
- 컴퓨터과학 == 알고리즘과학 : 알고리즘의 한계, 알고리즘의 분석, 알고리즘의 개발, 알고리즘의 실행, 알고리즘간의 통신, 알고리즘의 표현   
- 알고리즘의 개념 : 문제 풀이 절차/방법 == 주어진 문제를 해결하거나 함수를 계산하기 위해 따라야 할 명령어들을 단계적으로 나열한 것   
- 알고리즘의 조건 : (입출력, 명확성, 유한성, 유효성) + (실용적 관점에서의 효율성)   
   
### 알고리즘의 조건   
주어진 문제에 대한 하나 이상의 결과를 생성하기 위해 모호하지 않고 단순 명확하며 컴퓨터가 수행할 수 있는 유한개의 일련의 명령어들을 순서에 따라 구성한 것   
1. 입출력 : 0개 이상의 외부 입력과 1개 이상의 출력을 생성   
2. 명확성 : 각 명령은 모호하지 않고 단순 명확해야 함   
3. 유한성 : 한정된 수의 단계를 거친 후에는 반드시 종료함   
4. 유효성 : 모든 명령은 컴퓨터에서 수행할 수 있어야 함   
5. 실용적 관점에서의 효율성 : 알고리즘은 효율적이어야 함 (비정상적으로 수행시간이 오래 걸릴 경우 실행 불가)   
   
### 알고리즘 생성 과정   
설계 -> 표현/기술 -> 정확성 분석 -> 효율성 분석   
1. 설계 : 상향식 설계, 하향식 설계, 욕심쟁이 방법, 분할정복 방법, 동적 프로그래밍 방법 등   
2. 표현/기술 : 일상 언어, 순서도, 의사코드, 프로그래밍 언어 등   
3. 정확성 검증 : 수학적 증명   
4. 효율성 분석 : 공간 복잡도, 시간 복잡도   
   
### 대표적인 알고리즘 설계 기법   
- 욕심쟁이 방법 greedy method   
  - 해를 구하는 일련의 선택 과정마다 해당 단계에서 가장 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적인 전략을 취하는 방법   
  - 국부적인 최적해가 항상 전체적인 최적해를 구성하지 못하는 경우도 있음   
- 분할정복 방법 divide-and-conquer method   
  - 순환적으로 문제를 푸는 하향식 접근 방식으로, 주어진 문제의 입력을 더 이상 쪼갤 수 없을 때까지 2개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 방법   
  - 분할된 문제는 입력 크기만 작아졌을 뿐 원래 문제와 동일하며 서로 독립적   
  - ‘분할’-‘정복’-‘결합’의 단계로 구성   
- 동적 프로그래밍 방법 dynamic programming method   
  - 주어진 문제의 입력의 크기가 가장 작은 부분 문제부터 해를 구하여 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 원래의 문제를 점진적으로 해결하는 상향식 접근 방법   
  - 분할된 문제는 입력 크기만 작아졌을 뿐 원래 문제와 동일하며 서로 독립적일 필요는 없음   
   
### 욕심쟁이 방법 greedy method   
- 거스름돈 문제 coin change problem   
  - 가게에게 고객에게 돌려줄 거스름돈이 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제   
  - 동전의 액면가가 일반적인 경우에는 욕심쟁이 방법 적용 불가   
- 배낭 문제 knapsack problem   
  - 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾아내는 문제   
  - 물체를 쪼개서 넣을 수 없는 0/1 배낭 문제 : 배낭에 넣는 물체를 쪼갤 수 없다는 가정이 있는 배낭 문제로서, 이 경우에는 욕심쟁이 방법으로 해결할 수 없는 NP-완전문제가 된다.   
- 최소 신장 트리 문제 Minimum Spanning Tree (크루스칼 알고리즘 Kruskal's Algorithm, 프림 알고리즘 Prim's Algorithm)   
- 단일 출발점 최단 경로 문제 (데이크스트라 알고리즘 Dijkstra's Algorithm)   
   
### 분할정복 방법 divide-and-conquer method   
- 이진 탐색   
- 퀵 정렬   
- 합병 정렬   
   
### 동적 프로그래밍 방법 dynamic programming method   
- 모든 쌍 간의 최단 경로 문제 (플로이드 알고리즘 Floyd's Algorithm)   
- 연쇄적 행렬 곱셈 문제   
- 최장 공통 부분 수열 문제   
   
### 예시 - 최소값 찾기 알고리즘   
입력값 배열 : 80, 70, 40, 20, 30, 10, 60, 50   
- 일상 언어로 표현/기술하는 경우   
1. 첫번째 데이터를 최소값 [0]로 저장한다.   
2. 다음 숫자 [1]을 읽고, 이것과 저장된 최소값과 비교한다.   
3. 비교 후 더 작은 숫자를 최소값으로 다시 저장한다.   
4. 다음에 처리할 데이터가 남아 있으면 [2]로 간다.   
5. 저장된 최소값을 결과로 출력한다.   
   
- 의사코드 pseudo code 로 표현/기술하는 경우   
```
i = 1;
min = A[0];          // 데이터 A[0..n-1]
while(i < n) {
  A[i]가 min보다 작으면 min = A[i];
  i++;
}
최소값 min 출력;
```
   
### 예시 - 퀘닉스버그 다리 문제 - 오일러 경로 알고리즘   
그래프의 모든 간선을 오직 한번씩만 지나가는 경로 찾기   
1. 각 정점의 차수가 홀수인 정점이 0개 혹은 2개이어야 한다.   
2. 홀수점이 2개일 경우에는 홀수점에서 시작해야 한다.   
- 퀘닉스버그 다리는 정점 4개, 간선 7개, 차수가 홀수인 정점이 4개이므로 오일러 경로가 존재하지 않음   
