---
layout: post
title:  "Introduction to Algorithm: Design, Method"
date:   2024-02-27 09:00:00 +0900
categories: [Algorithm]
---

### 알고리즘 설계   
- 주어진 문제와 조건 등이 매우 다양함   
- 일반적/범용적인 설계 기법은 미존재   
   
### 대표적인 알고리즘 설계 기법   
- 욕심쟁이 방법 greedy method   
  - 탐욕적 방법, 탐욕 알고리즘   
  - 해를 구하는 일련의 선택 과정에서 전후 단계의 선택과는 상관없이 각 단계마다 가장 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적인 전략을 취하는 방법   
  - 각 단계마다 선택한 국부적인 최적해가 항상 전체적인 최적해를 구성하지 못하는 경우도 있음   
  - 간단하면서 효율적인 알고리즘을 만들 수 있는 강력한 기법   
  - 최소값/최대값을 구하는 최적화 문제에 주로 사용   
- 분할정복 방법 divide-and-conquer method   
  - 순환적으로 문제를 푸는 하향식 top-down 접근 방식   
  - 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 방법   
  - 분할된 문제는 입력 크기만 작아졌을 뿐 원래 문제와 동일   
  - 분할된 문제는 서로 독립적이므로 순환적인 분할 및 결과의 결합이 가능   
  - 각 순환 호출마다 세 단계의 작업을 수행 : ‘분할’-‘정복’-‘결합’의 단계로 구성   
    - 분할 : 주어진 문제의 입력을 여러 개의 작은 문제로 분할   
    - 정복 : 작은 문제들을 순환적으로 분할. 만약 작은 문제가 더이상 분할되지 않을 정도로 크기가 충분히 작으면 순환 호출 없이 작은 문제에 대한 해를 구함   
    - 결합 : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함   
- 동적 프로그래밍 방법 dynamic programming method   
  - 주어진 문제의 입력의 크기가 가장 작은 부분 문제부터 해를 구하여 테이블에 저장해 놓고, 이를 이용하여 입력 크기가 보다 큰 문제의 해를 점진적으로 해결해 가는 상향식 bottom-up 접근 방법   
  - 분할된 문제는 입력 크기만 작아졌을 뿐 원래 문제와 동일   
  - 분할된 문제들은 서로 독립적일 필요는 없음   
   
### 욕심쟁이 방법 greedy method 대표적인 적용 문제   
- 거스름돈 문제 coin change problem   
  - 동전 문제, 동전 거스름돈 문제   
  - 가게에게 고객에게 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제   
  - 기본 해결 방법 : 거스름돈의 액수를 초과하지 않으면서 동전의 액면가가 단순히 큰 것부터 욕심을 부려서 최대한 뽑아서 거스름돈을 만듦   
  - 동전의 액면가가 일반적인 경우에는 욕심쟁이 방법 적용 불가   
    - 예시 : 120원이라면 동전이 존재한다고 가정하고, 거스름돈이 650원 이라면 500원 동전 1개, 120원 동전 1개, 10원 동전 3개 -> 총 5개의 동전 필요   
    - 예시 : 120원이라면 동전이 존재하지 않으면, 거스름돈이 650원 이라면 500원 동전 1개, 100원 동전 1개, 50원 동전 1개 -> 총 3개의 동전 필요   
- 배낭 문제 knapsack problem   
  - 최대 용량 M인 하나의 배낭, n개의 물체가 있다고 가정하고, 각 물체 i에는 물체의 무게 Wi와 해당 물체를 배낭에 넣었을 때 얻을 수 있는 이익 Pi가 부여됨   
  - 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어있는 물체들의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법(또는 최대 이익)을 찾아내는 문제   
  - 기본 해결 방법 : 물체의 무게는 적으면서도 이익이 가장 큰 물체부터 골라서 욕심을 내어 최대한 넣는 과정을 반복. 단위 무게당 이익이 가장 큰 물체부터 최대한 넣는 과정을 반복   
    - 배낭에 넣는 물체를 쪼개서 넣을 수 있는 경우 배낭의 남은 용량에 맞게 물체를 쪼개서 넣음   
    - 배낭에 넣는 물체를 쪼개서 넣을 수 없는 0/1 배낭 문제 : 이 경우에는 욕심쟁이 방법으로 해결할 수 없는 NP-완전문제가 됨   
```
문제 표현
배낭 무게 용량 M = 10
물건 개수 n = 4
이익 (p1, p2, p3, p4) = (15, 20, 9, 14)
무게 (w1, w2, w3, w4) = (3, 5, 3, 4)

단위 무게당 이익
(p1, p2, p3, p4) = (5, 4, 3, 3.5)

배낭에 넣는 물체를 쪼개서 넣을 수 있는 경우
(p1, p2, p3, p4) = (1개 무게 3 이익 15, 1개 무게 5 이익 20, 1개를 쪼개어 무게 2만큼만 담음 이익 14/2 = 7, 0개)
-> 최대 이익 42

배낭에 넣는 물체를 쪼개서 넣을 수 없는 0/1 배낭인 경우
(p1, p2, p3, p4) = (1개 무게 3 이익 15, 1개 무게 5 이익 20, 0개, 0개)
-> 최대 이익 35
(p1, p2, p3, p4) = (1개 무게 3 이익 15, 0개, 1개 무게 3 이익 9, 1개 무게 4 이익 14)
-> 최대 이익 38
--> 욕심쟁이 방법으로 해결할 수 없는 NP-완전문제가 됨
```
- 최소 신장 트리 문제 Minimum Spanning Tree (크루스칼 알고리즘 Kruskal's Algorithm, 프림 알고리즘 Prim's Algorithm)   
- 단일 출발점 최단 경로 문제 (데이크스트라 알고리즘 Dijkstra's Algorithm)   
   
### 분할정복 방법 divide-and-conquer method 대표적인 적용 문제   
- 이진 탐색 binary search   
  - 이진 탐색 알고리즘과 분할정보 방법의 관계   
    - 분할 : 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 절반씩 분할. 탐색 키와 가운데 원소가 같으면 해당 원소의 배열 인덱스를 반환/종료   
    - 정복 : 탐색 키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출   
    - 결합 : 부분배열에 대한 탐색 결과가 직접 반환되므로 결합이 불필요   
- 퀵 정렬   
- 합병 정렬   
   
### 동적 프로그래밍 방법 dynamic programming method 대표적인 적용 문제   
- 모든 쌍 간의 최단 경로 문제 (플로이드 알고리즘 Floyd's Algorithm)   
- 연쇄적 행렬 곱셈 문제   
- 최장 공통 부분 수열 문제   
   
### 예시 - 최소값 찾기 알고리즘   
입력값 배열 : 80, 70, 40, 20, 30, 10, 60, 50   
- 일상 언어로 표현/기술하는 경우   
1. 첫번째 데이터를 최소값 [0]로 저장한다.   
2. 다음 숫자 [1]을 읽고, 이것과 저장된 최소값과 비교한다.   
3. 비교 후 더 작은 숫자를 최소값으로 다시 저장한다.   
4. 다음에 처리할 데이터가 남아 있으면 [2]로 간다.   
5. 저장된 최소값을 결과로 출력한다.   
   
- 의사코드 pseudo code 로 표현/기술하는 경우   
```
i = 1;
min = A[0];          // 데이터 A[0..n-1]
while(i < n) {
  A[i]가 min보다 작으면 min = A[i];
  i++;
}
최소값 min 출력;
```
   
### 예시 - 퀘닉스버그 다리 문제 - 오일러 경로 알고리즘   
그래프의 모든 간선을 오직 한번씩만 지나가는 경로 찾기   
1. 각 정점의 차수가 홀수인 정점이 0개 혹은 2개이어야 한다.   
2. 홀수점이 2개일 경우에는 홀수점에서 시작해야 한다.   
   
- 퀘닉스버그 다리는 정점 4개, 간선 7개, 차수가 홀수인 정점이 4개이므로 오일러 경로가 존재하지 않음   
